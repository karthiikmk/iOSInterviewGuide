# Mastering Algorithms and Data Structures for iOS Interviews

## Topics

### Summay

Summary of mastering algo and datastructures 

## Overview

overview text for this article  

### Section header

section header description

### Introduction
- Importance of algorithms and data structures in iOS interviews.
- How to approach algorithm questions in interviews.
- Tips for effective problem-solving and debugging.

## Data Structures

### Chapter 1: Fundamentals of Algorithms

* Understanding algorithm efficiency: Time Complexity and Space Complexity.
* Introduction to Big O, Big Ω (Omega), and Big Θ (Theta) notations.
* Comparing Recursive versus Iterative solutions.
- Stacks and Queues: Implementation and real-world applications in iOS.
- Hash Tables: Understanding hashing, collisions, and resolving collisions.

### Chapter 2: Strings

* Basic string operations and their complexities.
* String manipulation and challenges (reversals, permutations, compressions).
* Common string algorithms: pattern searching, longest substring, and string transformations.

### Chapter 3: Arrays
* Core operations on arrays (insertion, deletion, traversal, searching, and sorting).
* Challenges with arrays: handling duplicates, rotating arrays, and multi-dimensional arrays.
* Real-world iOS applications: Handling data collections efficiently.

### Chapter 4: Linked Lists
* Introduction to singly and doubly linked lists.
* Implementing basic operations: insertion, deletion, searching, and reversing a linked list.
* Advanced concepts: circular linked lists, the runner technique, and linked list problems relevant to iOS development.

### Chapter 5: Trees
* Basics of trees and binary trees: traversal algorithms (in-order, pre-order, post-order).
* Binary Search Trees (BST): Operations and applications.
* Advanced trees: AVL trees, Red-Black trees, and B-trees.
* Application of tree structures in iOS development: modeling hierarchical data, efficient data storage, and retrieval.

### Chapter 6: Graphs
* Understanding graphs: directed vs. undirected, weighted vs. unweighted.
* Graph representation techniques: adjacency list, adjacency matrix.
* Graph traversal algorithms: Depth-First Search (DFS), Breadth-First Search (BFS).
* Shortest path algorithms (Dijkstra's algorithm, A* search) and their applications in iOS (e.g., mapping, routing).

2) 𝐒𝐥𝐢𝐝𝐢𝐧𝐠 𝐖𝐢𝐧𝐝𝐨𝐰 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gjatQ5pK
3) 𝐓𝐰𝐨 𝐏𝐨𝐢𝐧𝐭𝐞𝐫𝐬 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gBfWgHYe
4) 𝐁𝐚𝐜𝐤𝐭𝐫𝐚𝐜𝐤𝐢𝐧𝐠 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/g9csxVa4

5) 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬 1: https://lnkd.in/gbpRU46g
6) 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬 2: https://lnkd.in/gcnBActT

7) 𝐁𝐢𝐧𝐚𝐫𝐲 𝐒𝐞𝐚𝐫𝐜𝐡 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gKEm_qUK
8) 𝐁𝐚𝐜𝐤𝐭𝐫𝐚𝐜𝐤𝐢𝐧𝐠 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gVkQX5vA

9) 𝐓𝐫𝐞𝐞 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gKja_D5H
10) 𝐆𝐫𝐚𝐩𝐡 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gKE6w7Jb

11) 𝐌𝐨𝐧𝐨𝐭𝐨𝐧𝐢𝐜 𝐒𝐭𝐚𝐜𝐤 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gdYahWVN
12) 𝐁𝐢𝐭 𝐌𝐚𝐧𝐢𝐩𝐮𝐥𝐚𝐭𝐢𝐨𝐧 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gmMMST5J
13) 𝐒𝐭𝐫𝐢𝐧𝐠 𝐐𝐮𝐞𝐬𝐭𝐢𝐨𝐧 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gkNvEi8j
14) 𝐃𝐅𝐒 + 𝐁𝐅𝐒 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬 (1): https://lnkd.in/gPgpsgaQ
15) 𝐃𝐅𝐒 + 𝐁𝐅𝐒 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬 (2): https://lnkd.in/gd4ekfQe
16) 14 𝐂𝐨𝐝𝐢𝐧𝐠 𝐈𝐧𝐭𝐞𝐫𝐯𝐢𝐞𝐰 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬: https://lnkd.in/gMZJVkFf

### Backtracking
Backtracking is a powerful algorithmic technique used to systematically search for solutions to computational problems. It is particularly useful for problems
where we need to make a series of decisions to reach a solution, with each decision leading to a sequence of further decisions until we either find a solution or
reach a dead end. Backtracking works by exploring all possible choices and recursively trying each choice until a valid solution is found or all choices have been
exhausted.

#### Key concepts and principles of backtracking:

1. Decision Tree: Backtracking problems can often be represented as decision trees, where each node represents a decision point and each edge represents a possible choice.
2. Pruning: Pruning involves eliminating branches of the search tree that cannot lead to a solution. This helps reduce the search space and improve efficiency.
3. Recursion: Backtracking is typically implemented using recursion, as it naturally captures the iterative nature of the problem-solving process.

The problems that can be solved using this tool generally satisfy the following criteria :

- You are explicitly asked to return a collection of all answers.
- You are concerned with what the actual solutions are rather than say the most optimum value 
of some parameter. (if it were the latter it’s most likely DP or greedy).


### middleIndex = startIndex + (endIndex - startIndex) / 2

## Begin
- func fib(_ position: Int) -> Int
- func fibUsingCache(_ position: Int) -> Int
- func climbStairs(_ n: Int) -> Int 
- func factorial(of number: Int) -> Int // f(n) = f(n-1) * n
- func isPrime(_ number: Int) -> Bool // using stride 

## Array 
- Reverse / Rotate Array 
- Merge two sorted array 
    - use two pointers, compare and add it in new array. 
    - dont forget to add the left over elements 
- Find duplicates in sorted / unsorted array (using visiteds)
- Remove duplicates in sorted 
    - use fast slow, increase the slow position to insert the fast  
- Find missing element (using differentiator)
- func removeElement(_ nums: inout [Int], _ val: Int) -> Int    
    - instead of mutating the array, gonna dump all the matching val in the end index 
    - reducing the endIndex position for the next matching values
- func twoSum(_ array: [Int], target: Int) -> [Int]
    - can be found using binary search (target should be considered as middle)
    - or can use differentiator and index cache to find the pair
- func findMaxConsecutiveOnces(_ nums: [Int]) -> Int 
    - use counter, and sum to track the consequeitve and maximum 

## Permutations
    - find all permutation for a give number (use recurrsion)
    - find next lexicographical permuation (use pivot and successor index concept) 

## Linked List

- func reverse(from node: Node?) -> Node?
- func removeDuplicates(inList head: Node?) -> Node?
- Find the middle element of a linked list. 
    - using fast and slow pointer we could able to find it 
    - or using middleIndex with normal iteration can help 
- func hasCycle(node: ListNode?) -> Bool
    - same as finding the middle index, using floyed cycle detection 
    - safly advancing by 2
- func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode?
    - get the length
    - Align the starting point
    - traverse togeather to find the intersection 

## Search 
- Ask is it sorted, then try to use Binary search (divide and conquire)

## Tree 
- TreeNode (value, left, right)
- AVLNode - self balancing (value, left, right, height)
- if anything w.r.t path, use dfs 
- if anythign w.r.t order, difference - use inorder
- BFS (level-order) - Queue
- DFS (pre-order)
- InorderTraversal == Ascending Sort
- Reverse Inorder traversal == Descending sort

## Graph 
- Vertex, Edge 
